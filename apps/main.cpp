#include <iostream>
#include <iomanip>
#include <string>
#include <memory>
#include <vector>
#include <chrono>                       // NEW

#include <core/Instance.h>
#include <solver/Solver.h>
#include <heuristics/ClarkeWrightSavings.h>
#include <heuristics/NearestNeighbor.h>
#include <local_search/Relocation.h>
#include <local_search/Swap.h>
#include <local_search/TwoOpt.h>

// ────────────────────────────────────────────────────────────────
// helpers
// ────────────────────────────────────────────────────────────────
static std::string getOpt(int argc, char* argv[],
                          const std::string& flag,
                          const std::string& def)
{
    for (int i = 2; i < argc - 1; ++i)
        if (argv[i] == flag) return argv[i + 1];
    return def;
}

static void printHeader(const cvrp::Instance& inst,
                        const std::string& heuristic,
                        const std::string& lsCfg,
                        double ms,
                        const cvrp::Solution& sol)
{
    using std::cout;
    cout << std::fixed << std::setprecision(3);
    cout << "NAME    : " << inst.name() << '\n'
         << "COMMENT : Generated by CVRP-Heuristics\n"
         << "TYPE    : HREAL\n"
         << "ROUTES  : " << sol.routes().size() << '\n'
         << "COST    : " << sol.totalCost()   << '\n'
         << "CONFIG  : heuristic=" << heuristic
         << ", ls=" << lsCfg << '\n'
         << "TIME_MS : " << ms << '\n'
         << "SOLUTION_SECTION\n"
         << " #R   SUMD        COST      LENGTH   #C   SEQUENCE\n";
}

static void printRoutes(const cvrp::Instance& inst,
                        const cvrp::Solution& sol)
{
    using std::cout;
    int r = 1;
    for (const auto& route : sol.routes()) {
        cout << std::setw(3) << r++
             << std::setw(8)  << route.load
             << std::setw(12) << std::setprecision(4) << route.length
             << std::setw(12) << std::setprecision(4) << route.length
             << std::setw(6)  << route.customers.size() << "   ";
        for (int c : route.customers) cout << c << ' ';
        cout << '\n';
    }
    cout << "DEPOT_SECTION\n" << inst.depot() << "\nEND\n";
}

// ────────────────────────────────────────────────────────────────
// main
// ────────────────────────────────────────────────────────────────
int main(int argc, char* argv[])
{
    if (argc < 2) {
        std::cerr <<
        "Usage: " << argv[0]
        << " <instance> "
           "[--heuristic cw|nn] "
           "[--ls none|reloc|swap|2opt|all]\n";
        return 1;
    }

    try {
        cvrp::Instance inst(argv[1]);

        // choose heuristic
        std::string hFlag = getOpt(argc, argv, "--heuristic", "cw");
        std::unique_ptr<cvrp::Heuristic> h;
        if      (hFlag == "cw") h = std::make_unique<cvrp::ClarkeWrightSavings>();
        else if (hFlag == "nn") h = std::make_unique<cvrp::NearestNeighbor>();
        else { std::cerr << "Unknown heuristic\n"; return 1; }

        // choose LS
        std::string lsFlag = getOpt(argc, argv, "--ls", "all");

        cvrp::Solver solver(std::move(h));
        if      (lsFlag == "reloc") solver.addOperator(std::make_unique<cvrp::Relocation>());
        else if (lsFlag == "swap")  solver.addOperator(std::make_unique<cvrp::Swap>());
        else if (lsFlag == "2opt")  solver.addOperator(std::make_unique<cvrp::TwoOpt>());
        else if (lsFlag == "all") {
            solver.addOperator(std::make_unique<cvrp::Relocation>());
            solver.addOperator(std::make_unique<cvrp::Swap>());
            solver.addOperator(std::make_unique<cvrp::TwoOpt>());
        } else if (lsFlag != "none") {
            std::cerr << "Unknown --ls option\n"; return 1;
        }

        // measure runtime
        auto t0 = std::chrono::steady_clock::now();
        cvrp::Solution sol = solver.run(inst);
        auto dt = std::chrono::duration<double, std::milli>(
                      std::chrono::steady_clock::now() - t0).count();

        // output
        printHeader(inst, hFlag, lsFlag, dt, sol);
        printRoutes(inst, sol);

    } catch (const std::exception& ex) {
        std::cerr << "Error: " << ex.what() << '\n';
        return 1;
    }
    return 0;
}
